# 정렬(심화)

## 1. `Tim Sort`란 무엇인가요?

Tim Sort 알고리즘의 철학은 '실제 데이터는 거의 정렬되어 있을 것이다' 라는 것을 가정합니다. 따라서 삽입정렬과 병합정렬을 채택하여 두 정렬 알고리즘을 혼합하는 방식으로 구현되어있습니다. `python`과 `Javascript` V8 엔진을 포함한 다양한 언어의 정렬 알고리즘에서 사용됩니다.

- 최선의 경우, `O(n)`, 평균적으로 `O(nlog(n))`, 최악의 경우 `O(nlog(n))`의 시간 복잡도를 가지며, 최악의 경우 `O(n**2)`의 시간복잡도를 갖는 퀵 정렬에 비해서 훨씬 빠릅니다.
- 퀵 정렬과는 달리 삽입 정렬과 병합 정렬의 알고리즘을 사용하므로, 안정 정렬에 속합니다.

## 2. 안정 정렬과 불안정 정렬에 대해 말씀해 주세요.

- 안정 정렬: 중복된 값을 정렬할 때 기존의 정렬 형태를 유지하는 정렬 알고리즘입니다.
- 불안정 정렬: 중복된 값을 정렬할 때 기존의 정렬 형태와 관계없이 무작위로 뒤 섞여 정렬되는 알고리즘입니다.

### 2-1. 대표적인 안정 정렬 알고리즘에 대해 알려주세요.

ex) `[(5, 0), (5, 1), (1, 2)]`

#### 버블 정렬

버블 정렬은 단순히 i번 인덱스의 값과 i + 1번 인덱스의 값을 비교하고, `arr[i] > arr[i + 1]`을 만족하는 경우에만 두 값을 스왑하므로, 중복된 값에 대하여 스왑 과정이 발생하지 않습니다.  

1. 0번 인덱스와 1번 인덱스의 값을 비교합니다. 두 값이 서로 동일하기 때문에 스왑 과정을 진행하지 않습니다.
2. 1번 인덱스와 2번 인덱스를 비교합니다. 2번 인덱스와 1번 인덱스의 값이 서로 동일하므로, 1번과 2번 인덱스의 값을 서로 바꿉니다. `[(5, 0), (1, 2), (5, 1)]`
3. 다음 사이클에서 0번과 1번 인덱스의 값을 비교할 때, 0번 인덱스의 값이 1번보다 크기 때문에 값을 스왑합니다. `[(1, 2), (5, 0), (5, 1)]`


#### 삽입 정렬
삽입 정렬 역시 버블 정렬과 비슷하게 `arr[i] < arr[i - 1]`을 만족하는 경우에만 두 값을 스왑합니다. 따라서 중복된 값에 대하여 스왑 과정이 발생하지 않습니다.  

1. 0번과 1번 인덱스를 비교합니다, 서로 동일한 5의 값을 갖기 때문에 스왑이 일어나지 않습니다.
2. 1번과 2번 인덱스를 비교합니다. 2번 인덱스의 값이 1번보다 크기 때문에 스왑이 발생합니다.`[(5, 0), (1, 2), (5, 1)]`
3. 0번과 1번의 값을 비교하여 스왑합니다. `[(1, 2), (5, 0), (5, 1)]`

#### 병합 정렬

병합 정렬의 병합 알고리즘은 다음과 같습니다.  

```tsx
while (left <= mid && arr[left] <= arr[right]) {
  ret[idx] = arr[left]
  idx += 1
  left += 1
}
...
```

두 배열의 요소를 비교하는 과정에서, left를 먼저 검사하며 left가 right 요소보다 작거나 같으면 먼저 삽입하기 때문에, 중복된 값에 대하여 순서가 보장됩니다.

### 2-2. 대표적인 불안정 정렬 알고리즘에 대해 알려주세요.

불안정 정렬은 기본적으로 바로 인접한 요소가 아닌 멀리 떨어진 요소와 값을 스왑하는 알고리즘에서 발생하는 특징입니다.  
ex) `[(5, 0), (1, 1), (5, 2), (2, 3)]`

#### 선택 정렬

선택 정렬은 minIndex를 현재의 인덱스로 설정한 뒤, 배열을 순회하면서 가장 작은 값을 찾게 되면 갱신합니다. 이 과정에서 값의 위치가 인접하지 않은 위치로 바뀔 수 있기 때문에 중복된 값의 순서가 바뀔 수 있습니다.  

1. `minIndex = 1`과 0번 인덱스의 값을 서로 스왑합니다. `[(1, 1), (5, 0), (5, 2), (2, 3)]`
2. `minIndex = 3`과 1번 인덱스의 값을 서로 스왑합니다. `[(1, 1), (2, 3), (5, 2), (5, 0)]` 

#### 퀵 정렬

`[(5, 0), (1, 1), (2, 3), (5, 2)]`

퀵 정렬은 피벗을 설정하고, 피벗을 기준으로 왼쪽은 피벗보다 작은 값, 오른쪽은 피벗보다 큰 값이 오도록 위치하는 알고리즘입니다. 이 피벗을 기준으로 `left`와 `right`의 값을 서로 바꾸는데, 이 과정에서 중복된 값의 순서가 바뀔 수 있습니다.

1. pivot을 0번 , left를 1번, right를 3번 인덱스로 설정합니다.
2. left는 오른쪽으로 탐색하면서 pivot보다 큰 값을, right는 왼쪽으로 탐색하면서 pivot보다 작은 값을 탐색합니다. 이때, left와 right가 서로 엇갈리면 탐색을 멈춥니다.
3. left는 4가 되고, right와 엇갈렸기 때문에 pivot과 right의 위치를 서로 바꿉니다. `[(5, 2), (1, 1), (2, 3), (5, 0)]`

## 출처
- [정렬 알고리즘 - 위키 백과](https://ko.wikipedia.org/wiki/%EC%A0%95%EB%A0%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)  
- [안정-정렬-VS-불안정-정렬-파이썬-알고리즘-인터뷰:velog-io](https://velog.io/@good159897/%EC%95%88%EC%A0%95-%EC%A0%95%EB%A0%AC-VS-%EB%B6%88%EC%95%88%EC%A0%95-%EC%A0%95%EB%A0%AC-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B8%ED%84%B0%EB%B7%B0)