**참고**

- https://poiemaweb.com/js-closure
- https://poiemaweb.com/js-execution-context

## 예상질문 및 답변

### 1. 클로저가 무엇인가요?

> 클로저란 자신이 생성된 환경인 스코프를 기억하여 해당 스코프 밖에서 호출되어도 기억한 스코프에 접근할 수 있는 함수를 의미합니다.

### 2. 클로저를 실행 컨텍스트의 관점에서 설명해주세요

> 외부함수와 내부함수가 있을 때, 내부함수는 외부함수의 변수를 참조하여 console.log 함수를 호출하고, 외부함수는 내부함수를 반환한다고 가정합니다.
>
> 외부함수 밖에서 변수에 외부함수를 할당하면
> 외부 함수는 종료되어 외부 함수의 실행 컨텍스트는 반환됩니다.
>
> 하지만 내부함수가 유효한 상태에서 외부함수가 종료되었다면, 내부함수에서 외부함수의 활성 객체를 스코프 체인을 통해 참조할 수 있으므로 유효한 값이 됩니다.
>
> 다시 말해 외부함수가 반환되어도 외부함수 내의 변수를 내부함수가 필요로 하므로 값이 유지가 됩니다.

### 2-1. 내부 함수는 외부 함수의 변수를 어떻게 참조할 수 있을까요?

> 내부 함수가 호출되면 자신의 실행 컨텍스트가 실행 컨텍스트 스택에 쌓이고 실행 컨텍스트 안에는 변수 객체와 스코프 체인 그리고 this에 바인딩할 객체가 존재합니다.
>
> 이때 스코프 체인은 전역 스코프를 가리키는 전역 객체, 외부 함수를 가리키는 외부 함수의 활성 객체, 자신의 스코프를 가리키는 활성 객체를 순차적으로 바인딩 합니다.
>
> 이렇게 순차적으로 저장되어있는 스코프 체인을 검색하여 상위 스코프에 접근할 수 있습니다.

### 3. 클로저를 사용하는 경우와 왜 사용하는지에 대해서 설명해주세요.

> 외부 함수가 즉시 실행함수를 이용하거나, 외부 함수를 생성자 함수로 선언하여 메서드를 이용해 값을 변경하고 변경된 최신 상태를 유지할 수 있습니다.
>
> 사용하는 이유는 전역 변수를 사용을 억제할 수 있기 때문입니다.
> 전역 변수를 사용하게 되면 언제든지 누구나 접근할 수 있으므로 많은 부작용을 일으켜 오류의 원인이 됩니다.

### 3-1. 전역 변수는 왜 누구나 접근할 수 있을 까요?

> 앞에서 말했던 실행 컨텍스트 관점에서 설명해 드리자면 실행 컨텍스트를 저장하는 실행 컨텍스트 스택에 실행 컨텍스가 쌓이고, 이 실행 컨텍스트에는 변수 객체, 스코프 체인, this 값이 있습니다.
>
> 변수 객체는 전역 컨텍스트의 경우 전역 변수와 전역 함수가 저장된 전역 객체, 함수 컨텍스트의 경우 변수, 매개변수와 인수 정보, 함수가 저장되어있는 활성 객체를 가리킵니다.
>
> 스코프 체인은 리스트 형태로 구현되어 있으며 자신을 포함하고 있는 함수의 활성 객체 또는 전역 객체를 가리킵니다.
>
> 따라서 전역 실행 컨텍스트를 제외한 모든 실행 컨텍스트들의 스코프 체인이 전역 객체를 가리키므로 어디서든지 접근할 수 있습니다.
