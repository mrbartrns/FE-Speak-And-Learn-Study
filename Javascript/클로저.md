**참고**

- https://poiemaweb.com/js-closure
- https://poiemaweb.com/js-execution-context
- https://leehwarang.github.io/docs/tech/2019-10-07-scope.html



## 1. 클로저가 무엇인가요?

> 클로저란 자신이 생성된 환경인 스코프를 기억하여 해당 스코프 밖에서 호출되어도 기억한 스코프에 접근할 수 있는 함수를 의미합니다.

## 2. 클로저를 실행 컨텍스트의 관점에서 설명해주세요

> 클로저란, 외부함수에서 반환된 내부함수가 반환 이후에도 생명주기를 유지하여 외부함수에서 선언된 변수를 참조할 수 있는 구조를 말합니다.

1. 외부함수가 호출되고 내부 함수를 반환합니다.
2. 외부함수가 종료되어 실행 컨텍스트에서 제거됩니다.
3. 그러나 내부 함수의 스코프 체인으로 선언 당시 외부 함수를 참조하므로, 해당 스코프에서 선언된 변수에 접근이 가능합니다. 
   1. 내부 함수에서 외부 함수에서 선언한 변수를 사용할 경우, 스코프체인을 통해 선언부를 찾아야하므로 외부 함수 스코프를 참조합니다. 따라서 가비지 컬렉션에 의하여 제거되지 않습니다.



### 2-1. 내부 함수는 외부 함수의 변수를 어떻게 참조할 수 있을까요?

자바스크립트에서 함수는 일급 객체입니다. 일급 객체가 함수처럼 동작하기 위해서는 `Lexical Environment`의 바인딩이 필요합니다.  
이 **`Lexical Envrionment`는 함수가 선언되는 시점에 생성되는 객체이기 때문에**, 스코프 체인 역시 생성되었을 때의 환경을 참조하므로 해당 inner function의 outer function을 참조하게 되며, 이는 변하지 않습니다.  
따라서 내부 함수에서 선언되지 않은 변수를 사용하더라도, 연결된 스코프 체인을 통해 상위 스코프의 `Lexical Environment`를 참조하여 선언부가 존재할 경우, 해당 변수를 참조할 수 있게 됩니다.


## 3. 클로저를 사용하는 경우와 왜 사용하는지에 대해서 설명해주세요.

> 외부 함수가 즉시 실행함수를 이용하거나, 외부 함수를 생성자 함수로 선언하여 메서드를 이용해 값을 변경하고 변경된 최신 상태를 유지할 수 있습니다.
>
> 전역 변수를 사용을 억제할 수 있기 때문입니다.
> 전역 변수를 사용하게 되면 언제든지 누구나 접근할 수 있으므로 많은 부작용을 일으켜 오류의 원인이 됩니다.

### 3-1. 전역 변수는 왜 누구나 접근할 수 있을 까요?

> 앞에서 말했던 실행 컨텍스트 관점에서 설명해 드리자면 실행 컨텍스트를 저장하는 실행 컨텍스트 스택에 실행 컨텍스가 쌓이고, 이 실행 컨텍스트에는 변수 객체, 스코프 체인, this 값이 있습니다.
>
> 변수 객체는 전역 컨텍스트의 경우 전역 변수와 전역 함수가 저장된 전역 객체, 함수 컨텍스트의 경우 변수, 매개변수와 인수 정보, 함수가 저장되어있는 활성 객체를 가리킵니다.
>
> 스코프 체인은 리스트 형태로 구현되어 있으며 자신을 포함하고 있는 함수의 활성 객체 또는 전역 객체를 가리킵니다.
>
> 따라서 전역 실행 컨텍스트를 제외한 모든 실행 컨텍스트들의 스코프 체인이 전역 객체를 가리키므로 어디서든지 접근할 수 있습니다.

## 4. 스코프 체인이 무엇인가요?

스코프 체인은 해당 코드의 스코프(유효 범위) 안에 있는 변수를 정의하는 객체의 체인입니다.  
자바스크립트 엔진은 해당 식별자를 찾을 때 자신의 속한 스코프에서 선언부를 찾고, 선언부가 존재하지 않을 경우 스코프체인으로 연결된 상위 스코프를 탐색하여 식별자의 선언부를 찾습니다.